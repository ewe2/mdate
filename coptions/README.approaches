Various approaches for the commandline parsing reassessment
===========================================================

Requirements:
c++ replacement for gengetopt that also parses configuration files for the
convenience of users.


pcode comparison between boost_program_options and gengetopt:
------------------------------------------------------------

pcode for gengetopt
~~~~~~~~~~~~~~~~~~~

executive summary:

gengetopt works ok
  - is not really c++ (getopt_long is ansi c). We could fix up the conversion
	functions here and there however. The format parsing in mdate.cpp is very
	c-based as it is. But we're effectively tied to a non-c++ mechanism.
  - doesn't support simultaneous and simple config-file handling.

boost works ok up to a point
  - does do the c++ well
  - does do config-file easily
  - requires careful overriding to get custom syntax, this is not
	well-documented.
  - depends on extra logic to validate arguments if they require more than one
	argument. For instance, using multitoken() doesn't solve the problem of
	where the tokenizing should end.


The primary use of gengetopt for mdate is to parse the commandline and store
the values of options for later use in int main(). Some options have no
arguments, some are switches, and some take specific argument formats. There
is also an implicit formatting option that does not use option syntax but is
recognized by its format if it exists.

where bool is whether the option is on/off and variable is whatever type the
specific argument.

struct gopt:
bool option_given = 0
variable item_argument = 0

clear_args() wipes the item_argument for any option_given: 

besides used to initialize the struct, it normally tidies up after an argument fails.

struct gopt is filled with the data from getopt_long(). Some options do not
require an argument, they are usually dealt with first. Options that have a
long form are mapped by the getop_long().

All this works except for format strings which, although they are checked for
option_given are NOT processed in the switch but outside of it.

switch (option_character)
	case option_character_no_argument:
		if option_given = 1:
			output_msg
			clear_args()
			exit
	case otpion_character_with_argument:
		if option_given = 1:
			output_error
			exit
		else
			count arguments
			optionally convert arguments
			continue
	esac
endswitch

Format strings are usually given at the end of a commandline string, but NOT
NECESSARILY. The algorithm merely searches the parsed commandline for a
specific format and treats that as the beginning of a format string. The code
implicitly assumes the parsing of options is ended by placing the following
logic outside the while {switch} loop.

scan remaining option index

if there's more than two, this is obviously an error and exit

if there's one, it could be our format string.

if it starts with a + but we somehow already got a format option, this is
another error, exit.

if it starts with a + and we haven't seen a format option, scan everything to
the end of the index and add a null to it (ie make a string, this would be a
vector<string> in c++).

if it doesn't start with a +, its not an option at all, and this is again an
error, exit.


pcode for boost_program_options.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The problem we face in boost is that we have a great mechanism for scanning
and storing the arguments, but managing how we parse the stored information is
tricky.

we can use local variables to search the commandline for matching arguments,
in effect casting those arguments directly to the type required.
this is in contrast to gengetopt which, although requiring the correct type to
be present in struct gengetopt, also requires us to cast TO those types from
getopt_long() which only sees arguments as strings.

the equivalent to struct gengetopt in boost is vm<map>. each parsed option is
matched with its argument type. eg 

"help","help text" or
"correlation",584285.0

an unfortunate side effect of this mostly desireable behaviour is that the
parser cannot tell where arguments end. See below:


start pcode:

describe options (this sets up name and value association)
add options to group (options can be grouped for specific handling ie
non-argument options, config-file options, hidden options, etc.)
add option groups to vm<map>

check for config-file if we specified one, output error if it doesn't exist,
store its options (we should by default install a config-file or create it if
it doesn't exist).

check vm.count for options
try
	if option found
		do something: parse the option or output the option or even check the
		option for erroneous arguments.
except
	output an error

end pcode.

This looks a lot simpler, and it is. But simple != workable as I argued above.
For instance, taking the -d argument: I could simply check if there was
only 3 arguments to it, and output an error, but if there are OTHER options or
a format string, the whole parse fails. The only simple answer is to treat the
arguments as a string, take only 3 and fall through like gengetopt, but this
breaks the logic of the library. Note that it isn't necessary to even put
checking logic in, the parse will fail simply because it has inappropriate
arguments passed to whatever function you assign to deal with the options,
forcing you to add validating logic of your own anyway.
